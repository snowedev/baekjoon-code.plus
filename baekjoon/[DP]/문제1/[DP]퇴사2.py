# 퇴사2 # B_15486
"""
그냥 퇴사 문제는 n제한이 15이하라서 상담을 하는경우/ 하지 않는 경우로 나누어
2^15 만에 모든 경우의 수를 다 해볼 수 있었지만 퇴사2는 n제한이 1,500,000
이어서 브루트포스로 불가능

-> 브루트 포스와 가장 큰 차이점은 브루트포스는 퇴사일이 되는 방법을 모두 구해서 그 중 최댓값을 구하는 것이고
   DP는 최댓값을 구할 수 있는 점화식을 세워서 i일 일때 무조건 최댓값을 가지도록 유도하는 것
----------------------------------------
점화식 D[i] = i일이 되었을 때, 최대 수익
-> i일 일때의 최대 수익을 구하면서 진행한다면 D[n+1]일 일때의 최대 수익을 구할 수 있음

* i일에 있는 상담을 하는 경우: D[i+T[i]]=max(D[i+T[i]], D[i]+P[i])
    * D[i+T[i]] = max( 0이거나 0이 아닌(상담안한 경우의 값이 저장되어 있어서) D[i+T[i]]값, 오늘 전까지의 수익+ 오늘 상담해서 번 수익 )
    * i+T[i]일이 된다
    * 수익은 P[i]이 늘어난다
* i일에 있는 상담을 하는 경우: D[i+1]=max(D[i+1], D[i])
    * D[i+1]의 값이 0이 아니라
    * i+1일이 된다
    * 수익은 그대로이다

정답: D[n+1]
"""

n = int(input())
t = [0]*n
p = [0]*n
for i in range(n):
    t[i], p[i] = map(int, input().split())

d = [0]*(n+50)  # 퇴사 날짜는 최대 50일까지 있음
for i in range(n):
    d[i+t[i]] = max(d[i+t[i]], d[i]+p[i])  # 상담을 하는 경우
    d[i+1] = max(d[i+1], d[i])  # 상담을 하지 않는 경우

print(d[n])
