"""
# 3으로 나누는 것이 수를 가장 빠르게 작게 만든다
# 우선순위 3으로 나누기 -> 2로 나누기 -> -1하기 순으로는 답을 구할 수 없음
# 10일 경우 10,5,4,2,1 보다 10,9,3,1이 더 빠르기 때문
# D[N]: N을 1로 만드는 최소 연산
    1. (N -> N/3) + (N/3 -> 1): D[N/3] + 1
    2. (N -> N/2) + (N/2 -> 1) : D[N/2] + 1
    3. (N -> N-1) + (N-1 -> 1): D[N-1] + 1
    D[N] = min(D[N/3], D[N/2] , D[N-1] ) + 1

# Python은 재귀를 사용하면 시간이 너무 오래 걸리고 메모리도 너무 많이 차지해서
# 실제로 제출하면 시간초과를 받게 됩니다.
# 따라서, Python은 다이나믹을 풀 때 Bottom-Up을 사용하는 것이 좋습니다.
"""
# 1로 만들기 # B_1463
# 시간 복잡도: O(n)
n = int(input())
d = [0]*(n+1)
d[1] = 0

for i in range(2,n+1):
    d[i] = d[i-1] + 1
    if i%2 == 0 and d[i] > d[i//2] + 1:
        d[i] = d[i//2] + 1
    if i%3 == 0 and d[i] > d[i//3] + 1:
        d[i] = d[i//3] + 1

print(d[n])